# 0. 环境设置与包加载
# 定义路径==================================================================
# 检查并安装必要的包 (如果已安装可跳过)
# if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
# BiocManager::install(c("ComplexHeatmap", "NMF"))
# install.packages(c("tidyverse", "factoextra", "dendextend", "RColorBrewer", "circlize"))

library(tidyverse)    # 数据清洗
library(factoextra)   # 聚类可视化
library(dendextend)   # 树状图
library(RColorBrewer) # 颜色
library(NMF)          # NMF聚类
library(ComplexHeatmap) # 复杂热图
library(circlize)     # 颜色映射
save_path=''

# ==============================================================================
# 1. 数据导入与基因名处理 (去重)
# 数据处理====================================================================
print("--- 正在导入并清洗数据 ---")
data_raw <- read.csv("Protein.csv", header = TRUE) 
save_path='Proteomics'
# 处理重复基因：按 Gene 分组，保留表达量之和最大的一行
data_raw_clean <- data_raw %>%
  # 确保 Gene 列存在
  filter(!is.na(Gene) & Gene != "") %>% 
  # 计算每行的总和 (排除前3列非数值列: Protein, Description, Gene)
  mutate(Total_Quant = rowSums(dplyr::select(., -Protein, -Description, -Gene), na.rm = TRUE)) %>% 
  # 按 Gene 分组，保留总值最大的一行
  group_by(Gene) %>%
  slice_max(Total_Quant, n = 1, with_ties = FALSE) %>% 
  ungroup() %>%
  # 移除不需要的列，只保留样本数据
  dplyr::select(-Protein, -Description, -Total_Quant) %>% 
  # 将 Gene 转为行名
  column_to_rownames(var = "Gene")
# 提取纯定量矩阵
quant_data <- data_raw_clean

#  Astral-DIA 标准化============================================================
# 2. Astral-DIA 标准化 (关键步骤)
# ==============================================================================
print("--- 执行 Astral-DIA 标准化 ---")
# 1. 计算每个样本的和
sum_sample <- colSums(quant_data, na.rm = TRUE)
# 2. 找到最大和
sum_max <- max(sum_sample)
# 3. 计算比值 Ratio
ratio <- sum_sample / sum_max
# 4. 执行标准化 (定量值 / Ratio)
normalized_data_df <- sweep(quant_data, MARGIN = 2, STATS = ratio, FUN = "/")



# 3. 缺失值插补与对数转换
#3. 缺失值插补与对数转换=======================================================
print("--- 执行缺失值处理与转换 ---")
# 极小值插补 (Min/2)
impute_data <- quant_data
impute_data <- normalized_data_df
for(i in 1:ncol(impute_data)){
  min_val <- min(impute_data[impute_data[, i] > 0, i], na.rm = TRUE)
  # 如果整列都是NA或0，给一个极小值防止报错
  if(is.infinite(min_val)) min_val <- 1 
  impute_data[is.na(impute_data[, i]) | impute_data[, i] == 0, i] <- min_val / 2
}
# Log2 转换
log_data <- log2(impute_data)
save(log_data,file='log_data.rda')
# 3. 高变筛选蛋白/RNA CPM log用mad，RNAcoutns用vst；蛋白不能用vst==============
TOP_PERCENTAGE <- 0.3 # <---【可修改】保留方差排名前 30%
# 1. 计算每个基因（行）的 MAD (中位数绝对偏差)
gene_mad <- apply(log_data, 1, mad)
# 打印 MAD 统计信息 (帮助您判断数据分布)
print(summary(gene_mad))
# 2. 确定要保留的基因数量
num_genes_to_keep <- round(nrow(log_data) * TOP_PERCENTAGE)
# 3. 找出高变基因的名称 (按 MAD 降序排列)
gene_mad_sorted <- sort(gene_mad, decreasing = TRUE)
high_variance_genes <- names(gene_mad_sorted)[1:num_genes_to_keep]
target_genes_of_interest <- c('ASCL1', 'YAP1', 'ASCL2', 'NEUROD1', 'CHGA', 'S100P', 'KLF5')
retained_target_genes <- intersect(high_variance_genes, target_genes_of_interest)
print(retained_target_genes)
# 4. 筛选 log_data 矩阵，覆盖原变量
log_data_filtered <- log_data[high_variance_genes, ]
save(log_data_filtered,file='log_data_filtered.rda')
log_data <- log_data_filtered # 供后续步骤使用

print(paste("原始基因数量:", nrow(log_data)))
print(paste("筛选后基因数量 (Top", TOP_PERCENTAGE*100, "%):", nrow(log_data)))
# Z-score 标准化 (用于 HC 和 K-means，以及热图可视化)
# 转置为 (样本 x 基因) 进行 scale，然后再转回 (基因 x 样本)
scaled_matrix_t <- scale(t(log_data)) 
scaled_data <- as.data.frame(scaled_matrix_t) # 样本为行，基因为列


# 4. 方法一：层次聚类 (Hierarchical Clustering)
# 层次聚类 (Hierarchical Clustering)=================================
print("--- 方法一：层次聚类 ---")
# 设定您想要的 HC 亚型数量
 # <---【可修改】在此指定 HC 的亚型数
dist_matrix <- dist(scaled_data, method = "euclidean")
hclust_result <- hclust(dist_matrix, method = "ward.D2")
plot(hclust_result, main = "层次聚类树状图", xlab = "样本", ylab = "距离", sub = "")
# 我们使用 fviz_nbclust 的 Silhouette 和 Elbow 方法来辅助选择 K
# 运行这个可能需要一些时间
fviz_nbclust(scaled_data, FUN = hcut, method = "silhouette", k.max = 10)
fviz_nbclust(scaled_data, FUN = hcut, method = "wss", k.max = 10)
# 根据 Silhouette 或 WSS 结果，假设我们决定分成 K=3 个亚型
K_HC <-5 
subtypes_hc <- cutree(hclust_result, k = K_HC)
dend <- as.dendrogram(hclust_result)
dend <- color_branches(dend, k = K_HC)
plot(dend, main = paste("层次聚类亚型 (K=", K_HC, ")"), 
     sub = "颜色代表不同的亚型")
# 结果存入数据框
subtype_df_hc <- data.frame(Sample = names(subtypes_hc), Subtype_HC = subtypes_hc)


# 5. 方法二：K-means 聚类
# K-means 聚类=======================================================
print("--- 方法二：K-means 聚类 ---")
# 设定您想要的 K-means 亚型数量 (通常与 HC 保持一致或通过肘部法则确定)
K_KM <- 5  # <---【可修改】在此指定 K-means 的亚型数
set.seed(42)
kmeans_result <- kmeans(scaled_data, centers = K_KM, nstart = 25)
fviz_cluster(kmeans_result, 
             data = scaled_data, 
             main = paste("K-means 聚类结果 (K=", K_KM, ")"),
             ellipse.type = "convex", # 椭圆类型
             geom = "point",          # 显示点
             palette = "jco"          # 颜色方案
)
subtypes_kmeans <- kmeans_result$cluster

# 结果存入数据框
subtype_df_kmeans <- data.frame(Sample = names(subtypes_kmeans), Subtype_Kmeans = subtypes_kmeans)

# ==============================================================================
# 6. 方法三：NMF 聚类 (非负矩阵分解)
# NMF 聚类=======================================
print("--- 方法三：NMF 聚类 ---")
# 准备非负矩阵 (Log数据平移)
min_log <- min(log_data)
V_nmf <- log_data - min_log # 确保 >= 0
results <- nmf(V_nmf, 
               rank = 2:8, 
               nrun = 100, 
               seed = 12345, 
               .opt = "v") # .opt="v" 用于显示进度

# 3. 绘制评估指标图，确定最佳 K
# Cophenetic 曲线：通常选择曲线斜率开始平稳下降的点
plot(results)
dir.create(save_path)
pdf(paste0(save_path,'/Proteomics_NMFsubtype.pdf'))
plot(results)
dev.off()
# 设定 NMF 秩 (K值)
# 注意：正式运行时请先运行 rank=2:8 nrun=50 查看评估图来决定 K
# 这里为了流程通畅，直接指定一个最佳 K
K_NMF <- 5 # <---【可修改】在此指定 NMF 的亚型数

# 运行 NMF
# 注意：.opt="v" 显示进度，p3 或 p4 可能会比较久，取决于数据量
nmf_model <- nmf(V_nmf, rank = K_NMF, nrun = 500, seed = 12345, .opt = "v") 

 # 提取亚型
# 修正：使用 coef() (系数矩阵 H) 来确定样本归属
H_matrix <- coef(nmf_model) 
subtypes_nmf <- max.col(t(H_matrix))

# 结果存入数据框
nmf_subtype_df <- data.frame(Sample = colnames(V_nmf), Subtype_NMF = subtypes_nmf)

# ==============================================================================
# 7. 结果合并
# 7. 结果合并================================================================
print("--- 合并聚类结果 ---")
all_subtypes_df <- subtype_df_hc %>% 
  left_join(subtype_df_kmeans, by = "Sample") %>%
  left_join(nmf_subtype_df, by = "Sample") %>%
  arrange(Sample) # 排序
print(head(all_subtypes_df))

# ==============================================================================
# 8. 绘制比较热图
# 8. 绘制比较热图============================================================
print("--- 绘制最终热图 ---")
# A. 准备特定基因列表
# 请务必修改为您数据中真实存在的基因名！
# 这里随机抽取前 30 个作为示例
target_genes <-genes_to_check
# 如果您有特定基因，请取消注释并填入：
# target_genes <- c("TP53", "BRCA1", "EGFR", "MYC") # <---【可修改】

# 检查基因是否都在数据中
valid_genes <- target_genes[target_genes %in% rownames(log_data)]
if(length(valid_genes) == 0) stop("错误：您选择的基因都不在数据中！")

# B. 提取作图数据 (使用 Z-score 后的数据)
# 注意：ComplexHeatmap 需要 基因 x 样本
plot_matrix <- t(scaled_data) # 已经是 Z-score 过的
plot_matrix_target <- plot_matrix[valid_genes, all_subtypes_df$Sample]

# C. 准备颜色
# 动态扩展颜色板，防止 K 值过大时报错
get_colors <- function(k) {
  cols <- colorRampPalette(brewer.pal(min(k, 8), "Set1"))(k)
  names(cols) <- 1:k
  return(cols)
}

col_hc <- get_colors(K_HC)
col_km <- get_colors(K_KM)
col_nmf <- get_colors(K_NMF)

# D. 顶部注释
ha <- HeatmapAnnotation(
  HC = as.factor(all_subtypes_df$Subtype_HC),
  Kmeans = as.factor(all_subtypes_df$Subtype_Kmeans),
  NMF = as.factor(all_subtypes_df$Subtype_NMF),
  col = list(HC = col_hc, Kmeans = col_km, NMF = col_nmf),
  annotation_name_side = "left",
  gap = unit(c(1, 1), "mm")
)

# E. 绘图
# 颜色映射 (Z-score: -2 到 2)
col_fun <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

ht <- Heatmap(plot_matrix_target,
              name = "Z-score",
              col = col_fun,
              top_annotation = ha,
              
              # 按 NMF 结果切分列
              column_split = all_subtypes_df$Subtype_NMF,
              column_title = "Samples (Split by NMF)",
              
              # 聚类设置
              cluster_columns = TRUE,
              cluster_rows = TRUE,
              show_column_names = FALSE,
              row_names_gp = gpar(fontsize = 8)
)

draw(ht, merge_legend = TRUE)
pdf( paste0(save_path, "/markergens.pdf"))
draw(ht, merge_legend = TRUE)
dev.off()

# 9.评估聚类一致性====================================================
library(cluster)
# 1. 评估 HC 结果
sil_hc <- silhouette(subtypes_hc, dist(scaled_data, method = "euclidean"))
avg_sil_hc <- mean(sil_hc[, 3])

# 2. 评估 K-means 结果
sil_km <- silhouette(kmeans_result$cluster, dist(scaled_data, method = "euclidean"))
avg_sil_km <- mean(sil_km[, 3])

# 3. 结果比较  $[-1, 1]
cat("--- 平均剪影系数 (K=", K_HC, ") ---\n")
cat("HC 剪影系数:", round(avg_sil_hc, 3), "\n")
cat("K-means 剪影系数:", round(avg_sil_km, 3), "\n")
# 可视化 HC 剪影图
fviz_silhouette(sil_hc, print.summary = FALSE)

library(mclust) # ARI 函数在 mclust 包中
# 比较 HC 与 NMF 的一致性
ari_hc_nmf <- adjustedRandIndex(all_subtypes_df$Subtype_HC, all_subtypes_df$Subtype_NMF)
ari_km_hc <- adjustedRandIndex(all_subtypes_df$Subtype_Kmeans, all_subtypes_df$Subtype_HC)
ari_km_nmf <- adjustedRandIndex(all_subtypes_df$Subtype_Kmeans, all_subtypes_df$Subtype_NMF)
cat("--- 聚类方法间的一致性 (ARI) ---\n")
cat("HC vs NMF ARI:", round(ari_hc_nmf, 3), "\n")
cat("K-means vs NMF ARI:", round(ari_km_nmf, 3), "\n")
cat("K-means vs HC ARI:", round(ari_km_hc, 3), "\n")
# ARI 解释： 0.8+ 代表高度一致，0.5-0.8 代表中等到良好一致。

# 10.提取聚类特征====================================================
W_matrix <- basis(nmf_model)  # 或者使用: coef(nmf_model)
# 查看维度
print(dim(W_matrix))
print(paste("基因数:", nrow(W_matrix), "因子数:", ncol(W_matrix)))

# 为每个因子提取top N基因
top_n_genes <- 50  # 每个因子提取前50个基因
factor_names <- paste0("Factor_", 1:K_NMF)

# 创建一个列表存储每个因子的top基因
top_genes_list <- list()

for(i in 1:K_NMF){
  # 按权重降序排序
  gene_weights <- W_matrix[, i]
  gene_names <- rownames(W_matrix)
  
  # 排序
  sorted_indices <- order(gene_weights, decreasing = TRUE)
  sorted_genes <- gene_names[sorted_indices]
  sorted_weights <- gene_weights[sorted_indices]
  
  # 取前top_n_genes个
  top_genes_list[[factor_names[i]]] <- data.frame(
    Gene = sorted_genes[1:top_n_genes],
    Weight = sorted_weights[1:top_n_genes],
    Rank = 1:top_n_genes
  )
  
  # 打印每个因子的top 10基因
  print(paste("Factor", i, "Top 10 genes:"))
  print(head(top_genes_list[[factor_names[i]]], 10))
}
dir.create(save_path)
# 保存结果
for(i in 1:K_NMF){
  write.csv(top_genes_list[[factor_names[i]]], 
            paste0(save_path, "/factor_", i, "_top_genes.csv"), 
            row.names = FALSE)
}




write.csv(all_subtypes_df , 
          paste0(save_path, "/Proteomicssubtype.csv"), 
          row.names = FALSE)

target_genes=unique(unlist(top_genes_list))
valid_genes <- target_genes[target_genes %in% rownames(log_data)]
if(length(valid_genes) == 0) stop("错误：您选择的基因都不在数据中！")

# B. 提取作图数据 (使用 Z-score 后的数据)
# 注意：ComplexHeatmap 需要 基因 x 样本
plot_matrix <- t(scaled_data) # 已经是 Z-score 过的
plot_matrix_target <- plot_matrix[valid_genes, all_subtypes_df$Sample]

# C. 准备颜色
# 动态扩展颜色板，防止 K 值过大时报错
get_colors <- function(k) {
  cols <- colorRampPalette(brewer.pal(min(k, 8), "Set1"))(k)
  names(cols) <- 1:k
  return(cols)
}

col_hc <- get_colors(K_HC)
col_km <- get_colors(K_KM)
col_nmf <- get_colors(K_NMF)

# D. 顶部注释
ha <- HeatmapAnnotation(
  HC = as.factor(all_subtypes_df$Subtype_HC),
  Kmeans = as.factor(all_subtypes_df$Subtype_Kmeans),
  NMF = as.factor(all_subtypes_df$Subtype_NMF),
  col = list(HC = col_hc, Kmeans = col_km, NMF = col_nmf),
  annotation_name_side = "left",
  gap = unit(c(1, 1), "mm")
)

# E. 绘图
# 颜色映射 (Z-score: -2 到 2)
col_fun <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

ht <- Heatmap(plot_matrix_target,
              name = "Z-score",
              col = col_fun,
              top_annotation = ha,
              
              # 按 NMF 结果切分列
              column_split = all_subtypes_df$Subtype_NMF,
              column_title = "Samples (Split by NMF)",
              
              # 聚类设置
              cluster_columns = TRUE,
              cluster_rows = TRUE,
              show_column_names = FALSE,
              row_names_gp = gpar(fontsize = 8)
)
pdf( paste0(save_path, "/Topgenes.pdf"))
draw(ht, merge_legend = TRUE)
dev.off()























